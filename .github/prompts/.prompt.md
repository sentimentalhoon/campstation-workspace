You are a senior full‑stack engineer and architect. Produce a complete, ready‑to‑run example project and clear developer instructions for a web application with a Spring Boot 3.5.6 backend (Java 21) and a React 18 frontend (Vite or Create React App is acceptable). Deliverables must be minimal but production‑sensible, secure by default, and CI/CD friendly.
Requirements and constraints
• Backend: Spring Boot 3.5.6, Java 21, use Gradle (Kotlin DSL) or Maven (choose Gradle by default). Provide build files, recommended dependency versions, and jlink/packaging notes if relevant.
• Frontend: React 18, TypeScript, Vite recommended. Use functional components, React Router, and axios or fetch for API calls.
• API design: REST endpoints with JSON; include one authenticated endpoint and one public endpoint. Use JWT for auth with refresh token flow example.
• Security: Spring Security configuration for JWT; CORS restricted to frontend origin; secure default headers; password hashing with BCrypt.
• Data: Use an in-memory H2 profile for local dev and PostgreSQL configuration for production (show application-{profile}.yml).
• Image Handling: Set to always use presigned URLs for image upload and download.
• Docker: Multi-stage Dockerfiles for backend and frontend, small runtime images, and a docker-compose.yml to run backend, frontend, and PostgreSQL.
• Testing: Unit tests for services and controllers (JUnit 5, MockK or Mockito), integration test for at least one endpoint using Testcontainers with PostgreSQL.
• CI: Provide GitHub Actions workflow that builds, tests, and builds Docker images, and demonstrates caching of Gradle and Node modules.
• Dev DX: Run instructions, common troubleshooting tips, and recommended IDE settings for Java 21 and TypeScript.
• Observability: Basic logging config (logback), actuator endpoints enabled on secure path, and simple Prometheus metrics exposition.
• Performance: HTTP keepalive, gzip, and recommended JVM flags for Java 21 in production Docker run.
• Outputs: For each file requested, return the file path and complete file content. Mark which files are templates to edit with environment variables.
Concrete outputs to generate
• Project root README.md with quick start and commands.
• Gradle build files (settings.gradle.kts, build.gradle.kts) or Maven equivalents.
• src/main/kotlin or java files for: Application, WebSecurityConfig, JwtUtil, AuthController, UserController, UserService, UserRepository (JPA), DTOs, Exception handlers.
• src/test files with at least one unit and one integration test using Testcontainers.
• application.yml and application-dev.yml and application-prod.yml with profile examples.
• Dockerfile.backend and Dockerfile.frontend and docker-compose.yml.
• frontend package.json, tsconfig.json, vite.config.ts, src/main.tsx, App.tsx, pages/Login.tsx, components/ProtectedRoute.tsx, api/api.ts.
• .github/workflows/ci.yml for build/test/docker.
• sample SQL migration file (Flyway or Liquibase) to create users table.
• Example curl commands for login, refresh, and protected endpoint with expected responses.
Constraints on your response
• Return only the files and content that a developer can paste into a repo and run after filling environment variables. For large files keep them concise but complete and runnable.
• Use secure defaults and point out any values that must be set as secrets.
• Keep explanations minimal; focus on producing concrete files and commands. End with a short checklist of acceptance criteria.
If any assumption is needed, assume frontend runs on http://localhost:5173 and backend on http://localhost:8080 unless overridden. Use PostgreSQL 15+ for production.
Framing examples
• Provide one complete controller example that shows JWT auth applied, request/response DTOs, validation annotations, and error handling.
• Provide one complete React login flow that stores access token in memory and refresh token in HttpOnly cookie, showing how to call protected API and handle 401 -> refresh flow.
Framed output format
• For each file, output a heading with the file path, then the exact file content. After files, output the Quick Start commands and the Acceptance Checklist.
